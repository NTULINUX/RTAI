# Copyright (C) 2005-2017 The RTAI project
# This [file] is free software; the RTAI project
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.

                 ***** RTAI POSIX SUPPORT IN USER SPACE *****

Here is what RTAI POSIX uses to support allowing you to use plain POSIX names.
It is an excerpt from "man ld" read it all there, even if all what of interest
is copied below.

.....
       --wrap symbol
           Use a wrapper function for symbol.  Any undefined reference to 
           symbol will be resolved to "__wrap_symbol". Any undefined reference
           to "__real_symbol" will be resolved to symbol.

           This  can  be used to provide a wrapper for a system function.  The
           wrapper function should be called "__wrap_symbol".  If it wishes to
           call the system function, it should call "__real_symbol".

           Here is a trivial example:

                   void *
                   __wrap_malloc (size_t c)
                   {
                     printf ("malloc called with %zu\n", c);
                     return __real_malloc (c);
                   }

           If you link other code with this file using --wrap malloc, then all
           calls to "malloc" will call the function  "__wrap_malloc"  instead.
           The  call  to "__real_malloc" in "__wrap_malloc" will call the real
           "malloc" function.

           You may wish to provide a "__real_malloc" function as well, so that
           links  without the --wrap option will succeed.  If you do this, you
           should not put the definition of "__real_malloc" in the  same  file
           as  "__wrap_malloc";  if you do, the assembler may resolve the call
           before the linker has a chance to wrap it to "malloc".
.....

In case you suspect the need to use a __real POSIX-something function you should
know that it should happen just for the functions listed in POSIX_WRAPS, found 
in this subdirectory.

Hard real time service are only those listed in POSIX_WRAPS and include:
- clocking/timing (CLOCK_MONOTONIC only),
- mutexes (normal, pshared, NORMAL, ERROCHECKING, RECURSIVE;
           PRIOINHER/PRIOCELING as configured for RTAI),
- semaphores (normal, pshared, named),
- barrier (normal, pshared, named),
- condition variables,
- rwlocks,
- spinlocks,
- message queues.

All the rest comes as for POSIX made available by the operating system and is
up to you to know if it can be used in real time or not. There is much that
can be, but a few critical services, e.g. thread creation, signal, joins,
and cancellations will send your thread to soft mode. You must be aware of it.
Overall it is believed that those services can be crafted appropriately
during initialisation/closure, so that true hard real time is possible always.

Notice also that you cannot use static initialisations because of the reuse
RTAI does of the related structures.

A lot of examples showing RTAI POSIX at work can be found in:
"showroom/v3.x/posix/user" and related subdirectories therof.

It is important to remark that it has been chosen to not enable threads for
RTAI directly, but you have to do it specifically, either by calling the 
standard rt_task_init_schmod or the specific pthread_setschedparam_np. The
latter is an overall container for RTAI scheduling management, is up to you
to possibly mate it with standard POSIX calls to keep Linux and RTAI aligned,
but beware that doing so you'll be sent in soft real time, while 
pthread_setschedparam_np is hard real time, except for hard/soft/switches
naturally. "Showroom/v3.x/posix/user" can be your helper once more.

Last, but not least, POSIX can be used with RTAI, to the point that an object
created by one can be used by the other.
